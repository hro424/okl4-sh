/* $Id$ */

/**
 * @brief   SH7780 Trap Handling
 * @file    pistachio/src/traps.spp
 * @since   December 8, 2008
 */

#include <asmsyms.h>
#include <arch/config.h>
#include <arch/exception.h>
#include <arch/globals.h>
#include <arch/syscalls.h>
#include <kernel/arch/asm.h>
#include <kernel/arch/config.h>


#define KERNEL_STACK                __stack + STACK_TOP
#define GENERAL_EXCEPTION_HANDLER   do_general_exception
#define SYSCALL_EXCEPTION_HANDLER   do_syscall_exception
#define TLB_HANDLER                 do_tlb_miss
#define IRQ_HANDLER                 soc_handle_interrupt

#define SWITCH_BANK_1_TO_0              \
    stc     sr, r0;                     \
    /* Make the mask to switch the bank */  \
    mov     #0x20, r1;                  \
    shll8   r1;                         \
    shll16  r1;                         \
    not     r1, r1;                     \
    /* Switch bank 1 to bank 0 */       \
    and     r1, r0;                     \
    ldc     r0, sr

#define SAVE_CONTEXT                    \
    stc.l   sgr, @-r15;                 \
    stc.l   spc, @-r15;                 \
    stc.l   ssr, @-r15;                 \
    sts.l   pr, @-r15;                  \
    sts.l   macl, @-r15;                \
    sts.l   mach, @-r15;                \
    /* The current bank is 1.  */       \
    SWITCH_BANK_1_TO_0;                 \
    /* Push the rest of the registers on to the stack */    \
    PUSH(r14);                          \
    PUSH(r13);                          \
    PUSH(r12);                          \
    PUSH(r11);                          \
    PUSH(r10);                          \
    PUSH(r9);                           \
    PUSH(r8);                           \
    PUSH(r7);                           \
    PUSH(r6);                           \
    PUSH(r5);                           \
    PUSH(r4);                           \
    PUSH(r3);                           \
    PUSH(r2);                           \
    PUSH(r1);                           \
    PUSH(r0)


#define RESTORE_CONTEXT                 \
    POP(r0);                            \
    POP(r1);                            \
    POP(r2);                            \
    POP(r3);                            \
    POP(r4);                            \
    POP(r5);                            \
    POP(r6);                            \
    POP(r7);                            \
    POP(r8);                            \
    POP(r9);                            \
    POP(r10);                           \
    POP(r11);                           \
    POP(r12);                           \
    POP(r13);                           \
    POP(r14);                           \
    lds.l   @r15+, mach;                \
    lds.l   @r15+, macl;                \
    lds.l   @r15+, pr;                  \
    ldc.l   @r15+, ssr;                 \
    ldc.l   @r15+, spc;                 \
    /*XXX: Compile error: ldc.l   @r15+, sgr; */                \
    mov.l   @r15, r15



/*
 * Locate the trap vector in the P1 or P2 domain in order to avoid double
 * fault.
 *
 * P1 (0x80000000 - 0x9FFFFFFF):
 *      Cacheable but address translation via TLB is impossible.
 * P2 (0xA0000000 - 0xBFFFFFFF):
 *      Uncacheable and address translation via TLB is impossible.
 */

/*
 * Initialize the layout of the trap handler
 */
    TRAPS_BEGIN_MARKER

/*
* GENERAL EXCEPTION HANDLER (VBR, Offset:0x100)
*/
    BEGIN_PROC_TRAPS(sh_exception, 0x100)

    /* Using register bank 1 */

    /*
     * Read the exception event register, which includes 11-bit of
     * exception code
     */
    mov.l   EXP_CONST_REG_EXPEVT, r0
    mov.l   @r0, r0

    /* Branch to TRAPA exception handling */
    mov.l   EXP_CONST_ECODE_TRAPA, r1
    cmp/eq  r1, r0
    bt      sh_handle_trapa

#if 0
    /* Branch TLB exception handling */
    cmp/eq  EXP_CONST_ECODE_TLB_FAULT_R, r0
    bt      sh_handle_tlb_fault
    cmp/eq  EXP_CONST_ECODE_TLB_FAULT_W, r0
    bt      sh_handle_tlb_fault

    /* Branch to initial write exception handling */
    cmp/qe  EXP_CONST_ECODE_INIT_WRITE, r0
    bt      sh_handle_init_write
#endif

    /* Deal with it as general exception */

    mov.l   EXP_CONST_STACK, r15
    SAVE_CONTEXT

    /* Using register bank 0 */

    /*
     * Pass the exception code to the handler (a C function) via the
     * first argument
     */
    mov.l   EXP_CONST_REG_EXPEVT, r4
    mov.l   @r4, r4

    /*
     * Pass the current SP, which points at sh_context_t, to the handler
     * via the second argument
     */
    mov     r15, r5

    /* Invoke the handler */
    /* handle(uint32_t exception, sh_context_t* context) */
    mov.l   EXP_CONST_GENERAL_EXCEPTION_HANDLER, r0
    jsr     @r0
    nop

    RESTORE_CONTEXT
    rte
    nop
    /* NOT REACHED */

    /*
     * TRAPA Handler (Exception code: 0x160)
     */
LABEL(sh_handle_trapa)
    /* Using register bank 1 */

    /* See if the TRAPA code indicates a system call */
    mov.l   EXP_CONST_REG_TRA, r0
    mov.l   @r0, r0
    /* Omit 2 LSBs.  See the manual.  */
    shlr2   r0
    cmp/eq  #SYSCALL_NUM, r0
    bt      sh_handle_syscall

    /* Not a system call.  Throw a system call exception.  */
    SAVE_CONTEXT

    /* Using register bank 0 */

    mov     r15, r4

    /* Set the return address */
    mov.l   error_return, r0
    lds     r0, pr

    /* Invoke the handler */
    /* handle(sh_context_t* context) */
    mov.l   EXP_CONST_SYSCALL_EXCEPTION_HANDLER, r0
    jmp     @r0
    nop
    /* NOT REACHED */

LABEL(error_return)
    /* Restore context from TCB */
    mov.l   EXP_CONST_GLOBAL, r15
    add     #OFFSET_GLOBAL_CURRENT_TCB, r15
    mov.l   @r15, r15
    add     #OFFSET_TCB_ARCH_CONTEXT, r15
    RESTORE_CONTEXT
    rte
    nop
    /* NOT REACHED */


    /*
     * System call handler
     */
LABEL(sh_handle_syscall)
    /* Using register bank 1 */

    /* Save the control and system registers to TCB */
    mov.l   EXP_CONST_GLOBAL, r0
    add     #OFFSET_GLOBAL_CURRENT_TCB, r0
    mov.l   @r0, r0
    add     #OFFSET_TCB_ARCH_CONTEXT, r0
    mov.l   EXP_CONST_SIZEOF_CONTEXT, r1
    add     r1, r0
    stc.l   sgr, @-r0
    stc.l   spc, @-r0
    stc.l   ssr, @-r0
    sts.l   pr, @-r0
    sts.l   macl, @-r0
    sts.l   mach, @-r0

    /* Switch to the kernel stack */
    mov.l   EXP_CONST_STACK, r15

    /* Set the return address */
    mov     r8, r0
    cmp/eq  #SYSCALL_ipc, r0
    mov.l   syscall_return, r0
    bf      1f
    mov.l   ipc_syscall_return, r0
1:
    lds     r0, pr

    SWITCH_BANK_1_TO_0

    /* Using register bank 0 */

    /* Restore the 5th-8th arguments */
    mov.l   r3, @-r15
    mov.l   r2, @-r15
    mov.l   r1, @-r15
    mov.l   r0, @-r15

    /* Call it.  r8 holds syscall number. */
    mov.l   sh_syscall_vectors, r0
    shll2   r8
    add     r8, r0
    jmp     @r0
    nop
    /* NOT REACHED */

LABEL(ipc_syscall_return)
    mov.l   EXP_CONST_GLOBAL, r15
    add     #OFFSET_GLOBAL_CURRENT_TCB, r15
    mov.l   @r15, r15
    mov.l   EXP_CONST_OFFSET_TCB_PARTNER, r14
    add     r14, r15
    mov.l   @r15, r0

    /* FALL THROUGH */

LABEL(syscall_return)
    /* Restore the control and system registers from TCB */
    mov.l   EXP_CONST_GLOBAL, r15
    add     #OFFSET_GLOBAL_CURRENT_TCB, r15
    mov.l   @r15, r15
    add     #OFFSET_TCB_ARCH_CONTEXT, r15
    mov.l   EXP_CONST_OFFSET_CONTEXT_MACH, r14
    add     r14, r15
    
    lds.l   @r15+, mach
    lds.l   @r15+, macl
    lds.l   @r15+, pr
    ldc.l   @r15+, ssr
    ldc.l   @r15+, spc
    /*ldc.l   @r15+, sgr */
    stc     sgr, r15
    rte
    nop    
    /* NOT REACHED */


    /* Constant values and function pointers */
    .align 2
LABEL(EXP_CONST_REG_EXPEVT)
    .long   REG_EXPEVT

LABEL(EXP_CONST_REG_TRA)
    .long   REG_TRA

LABEL(EXP_CONST_ECODE_TRAPA)
    .long   ECODE_TRAPA

LABEL(EXP_CONST_STACK)
    .long   KERNEL_STACK

LABEL(EXP_CONST_GENERAL_EXCEPTION_HANDLER)
    .long   GENERAL_EXCEPTION_HANDLER

LABEL(EXP_CONST_SYSCALL_EXCEPTION_HANDLER)
    .long   SYSCALL_EXCEPTION_HANDLER

LABEL(EXP_CONST_GLOBAL)
    .long   SH_GLOBAL_BASE

LABEL(EXP_CONST_SIZEOF_CONTEXT)
    .long   SIZEOF_CONTEXT

LABEL(EXP_CONST_OFFSET_CONTEXT_MACH)
    .long   OFFSET_CONTEXT_MACH

LABEL(EXP_CONST_OFFSET_TCB_PARTNER)
    .long   OFFSET_TCB_PARTNER

LABEL(sh_syscall_vectors)
    .long   sys_ipc
    .long   sys_thread_switch
    .long   sys_thread_control
    .long   sys_exchange_registers
    .long   sys_schedule
    .long   sys_map_control
    .long   sys_space_control
    .long   sys_cache_control
    .long   sys_ipc             /* lipc */
    .long   sys_platform_control
    .long   sys_space_switch
    .long   sys_mutex
    .long   sys_mutex_control
    .long   sys_interrupt_control
    .long   sys_cap_control
    .long   sys_memory_copy

    END_PROC_TRAPS(sh_exception)

/*
* TLB miss handler vector
*/
    BEGIN_PROC_TRAPS(sh_tlb_miss, 0x400)
    mov.l   TLB_CONST_STACK, r15
    SAVE_CONTEXT

    /*
     * The exception event register contains the access mode, such as
     * read (0x40) or write (0x60).  Pass it via the first argument.
     */
    mov.l   TLB_CONST_REG_EXPEVT, r4
    mov.l   @r4, r4

    /* Pass SP via the second argument */
    mov     r15, r5

    /* Call the handler */
    mov.l   TLB_CONST_TLB_HANDLER, r0
    jsr     @r0
    nop

    RESTORE_CONTEXT
    rte
    nop
    /* NOT REACHED */

    /* Constant values and function pointers */
    .align 2
LABEL(TLB_CONST_STACK)
    .long   KERNEL_STACK
LABEL(TLB_CONST_REG_EXPEVT)
    .long   REG_EXPEVT
LABEL(TLB_CONST_TLB_HANDLER)
    .long   TLB_HANDLER

    END_PROC_TRAPS(sh_tlb_miss)

/*
* IRQ handler vector
* NOTE: Must be placed at 0x600 (= 0x400 + 0x200)
*/
    BEGIN_PROC_TRAPS(sh_interrupt, 0x200)

    /* Check whether it is raised in user or kernel mode */
    /*TODO: bf      allocate_kernel_stack */
    
    /* Handle an interrupt raised in user mode */

    /* Use the kernel stack */
    mov.l   IRQ_CONST_STACK, r15

    SAVE_CONTEXT

    /*
     * Read the interrupt event register.  Pass it via the first argument.
     */
    mov.l   IRQ_CONST_REG_INTEVT, r4
    mov.l   @r4, r4

    /* Pass the saved context via the second argument */
    mov     r15, r5

    /* Invoke the IRQ handler */
    mov.l   IRQ_CONST_IRQ_HANDLER, r0
    jsr     @r0
    nop
    RESTORE_CONTEXT
    rte
    nop
    /* NOT REACHED */

LABEL(kernel_interrupt)
    /* Handle an interrupt raised in kernel mode */

    /* Allocate stack */

    SAVE_CONTEXT

    /*
     * Read the interrupt event register.  Pass it via the first argument.
     */
    mov.l   IRQ_CONST_REG_INTEVT, r4
    mov.l   @r4, r4

    /* Pass the saved context via the second argument */
    mov     r15, r5

    /* Invoke the IRQ handler */
    mov.l   IRQ_CONST_IRQ_HANDLER, r0
    jsr     @r0
    nop
    RESTORE_CONTEXT
    rte
    nop
    /* NOT REACHED */

    /* Constant values and function pointers */
    .align 2
LABEL(IRQ_CONST_STACK)
    .long   KERNEL_STACK
LABEL(IRQ_CONST_REG_INTEVT)
    .long   REG_INTEVT
LABEL(IRQ_CONST_IRQ_HANDLER)
    .long   IRQ_HANDLER

    END_PROC_TRAPS(sh_interrupt)

