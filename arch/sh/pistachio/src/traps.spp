/**
 * @brief   SH7780 trap handling routine
 * @file    arch/sh/pistachio/src/traps.spp
 * @since   December 8, 2008
 * @author  Hiroo Ishikawa <hiroo.ishikawa@gmail.com>
 */

#include <asmsyms.h>
#include <tcb_layout.h>
#include <arch/asm.h>
#include <arch/config.h>
#include <arch/exception.h>
#include <arch/globals.h>
#include <arch/syscalls.h>
#include <arch/thread.h>
#include <kernel/arch/asm.h> //TODO: Integrate this with asm.h
#include <kernel/arch/config.h>


#define KERNEL_STACK                __stack + STACK_TOP
#define TLB_HANDLER                 handle_tlb_exception


/*
 * Locate the trap vector in the P1 or P2 domain in order to avoid double
 * fault.
 *
 * P1 (0x80000000 - 0x9FFFFFFF):
 *      Cacheable but address translation via TLB is impossible.
 * P2 (0xA0000000 - 0xBFFFFFFF):
 *      Uncacheable and address translation via TLB is impossible.
 */

/*
 * Initialize the layout of the trap handler
 */
TRAPS_BEGIN_MARKER

/*
 * GENERAL EXCEPTION HANDLER (VBR, Offset:0x100)
 */
BEGIN_PROC_TRAPS(sh_general_exception, 0x100)
        /* Using register bank 1 (privileged bank) */

        /*
         * Store the exception event register, which includes 11-bit of
         * exception code, to r0 in bank1.
         */
        mov.l   1f, r0
        mov.l   @r0, r0

        /* Branch to a vector.  r0 holds EXPEVT */
        mov.l   2f, r1
        add     r0, r1
        jmp     @r1
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   REG_EXPEVT
2:      .long   sh_general_exception

        ALIGN   0x80
        .skip   0x20

        /*
         * General Exception Vector
         */
        /* Vector 1: TLB Protection Violation (read) (offset: 0xA0) */
        EXP_VECTOR(0x20, exp_memory_exception)

        /* Vector 2: TLB Protection Violation (write) (offset: 0xC0) */
        EXP_VECTOR(0x20, exp_memory_exception)

        /* Vector 3: Address Error (read) (offset: 0xE0) */
        EXP_VECTOR(0x20, exp_address_error)

        /* Vector 4: Address Error (write) (offset: 0x100) */
        EXP_VECTOR(0x20, exp_address_error)

        /* Vector 5: FPU Exception (offset: 0x120) */
        EXP_VECTOR(0x20, exp_instruction_exception)

        /* Vector 6: TRAPA (offset: 0x160) */
        EXP_VECTOR(0x40, exp_trapa_handler)

        /* Vector 7: Invalid Instruction (offset: 0x180) */
        EXP_VECTOR(0x20, exp_instruction_exception)

        /* Vector 8: Slot Invalid Instruction (offset: 0x1A0) */
        EXP_VECTOR(0x20, exp_instruction_exception)

        /* Vector 9: User Break (offset: 0x1E0) */
        EXP_VECTOR(0x40, exp_user_break)

END_PROC_TRAPS(sh_general_exception)


BEGIN_PROC(abort_return)
BEGIN_LOCAL_PROC(common_return)
        /* Restore the context from TCB */
        mov.l   1f, r15
        add     #OFS_GLOBAL_CURRENT_TCB, r15
        mov.l   @r15, r15
        add     #OFS_TCB_ARCH_CONTEXT, r15
        RESTORE_CONTEXT
        rte
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   SH_GLOBAL_BASE
END_LOCAL_PROC(common_return)
END_PROC(abort_return)



/*
 * TLB miss handler vector
 * NOTE: Must be placed at VBR + 0x400
 */
BEGIN_PROC_TRAPS(sh_tlb_miss, 0x400)
        /* Using register bank 1 */
        SAVE_CONTEXT
        /* Using register bank 0 */

        /*
         * The exception event register contains the access mode, such as
         * read (0x40) or write (0x60).  Pass it via the first argument.
         */
        mov.l   2f, r4
        mov.l   @r4, r4

        /* Pass the context via the second argument */
        mov     r15, r5

        /* Check whether it is raised in user or kernel mode */
        stc     ssr, r0
        rotl    r0
        rotl    r0
        bt      5f

        /* Load the kernel stack if from user mode*/
        mov.l   1f, r15
5:
        clrt

        /* Set up continuation */
        mov.l   4f, r0
        lds     r0, pr

        /* Call the handler */
        mov.l   3f, r0
        jsr     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   REG_EXPEVT
3:      .long   TLB_HANDLER
4:      .long   common_return

END_PROC_TRAPS(sh_tlb_miss)


/*
 * IRQ handler vector
 * NOTE: Must be placed at 0x600 (= 0x400 + 0x200)
 * TODO: Handling multiple interrupts
 */
BEGIN_PROC_TRAPS(sh_interrupt, 0x200)
        SAVE_CONTEXT
        /* Using register bank 0 */

        /*
         * Read the interrupt event register.
         * Pass it via the first argument.
         */
        mov.l   2f, r4
        mov.l   @r4, r4

        /* Pass the saved context via the second argument */
        mov     r15, r5

        /* Set up continuation */
        mov.l   3f, r0
        lds     r0, pr

        /* Check whether it is raised in user or kernel mode */
        stc     ssr, r0
        rotl    r0
        rotl    r0
        bt      kernel_interrupt

        /* Load the kernel stack */
        mov.l   1f, r15

        mov.l   4f, r0
        jmp     @r0
        nop
        /* NOT REACHED */

LABEL(kernel_interrupt)
        /* Handle an interrupt raised in kernel mode */
        clrt
        mov.l   4f, r0
        jsr     @r0
        nop

        /* Get current TCB to get continuation */
        mov.l   5f, r15
        add     #OFS_GLOBAL_CURRENT_TCB, r15
        mov.l   @r15, r15
        add     #OFS_TCB_PREEMPTION_CONTINUATION, r15
        mov     r15, r0

        /* Reset the kernel stack */
        mov.l   1f, r15

        /* Return to continuation */
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   REG_INTEVT
3:      .long   common_return
4:      .long   soc_handle_interrupt
5:      .long   SH_GLOBAL_BASE

END_PROC_TRAPS(sh_interrupt)

/*
 * The rest of general exception vectors
 * NOTE: Must be placed at VBR + 0x800
 */
        /* Vector 10: Invalid FPU Instruction (offset: 0x800) */
        EXP_VECTOR(0x200, exp_instruction_exception)

        /* Vector 11: Slot Invalid FPU Instruction (offset: 0x820) */
        EXP_VECTOR(0x20, exp_instruction_exception)

/*
 * Invokes the page fault handler that sends a page fault message to user.
 */
BEGIN_LOCAL_PROC(exp_memory_exception)
        /* Using register bank 1 */
        SAVE_CONTEXT
        /* Using register bank 0 (non-privileged bank) */

        /* Pass EXPEVT to the handler via the first argument.  */
        /* r0 in bank1 holds EXPEVT. */
        stc     r0_bank, r4

        /*
         * Pass the current context to the handler via the second argument.
         * The context is supposed to be saved to a TCB in the handler so that
         * the kernel return routine restores the context.
         */
        mov     r15, r5

        /* Check whether it was raised in user or kernel mode */
        stc     ssr, r0
        rotl    r0
        rotl    r0
        bt      4f

        /* Load the kernel stack if from user mode*/
        mov.l   1f, r15
4:
        clrt

        /* Set up continuation */
        mov.l   3f, r0
        lds     r0, pr

        /*
         * Call the handler
         */
        mov.l   2f, r0
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   TLB_HANDLER
3:      .long   common_return

END_LOCAL_PROC(exp_memory_exception)


BEGIN_LOCAL_PROC(exp_instruction_exception)
        SAVE_CONTEXT
        /* Using register bank 0 (non-privileged bank) */

        /*
         * Pass the exception code to the handler (a C function) via the
         * first argument. r0 in bank1 holds EXPEVT.
         */
        stc     r0_bank, r4

        /*
         * Pass the current SP, which points at sh_context_t, to the handler
         * via the second argument
         */
        mov     r15, r5

        /* Check whether it was raised in user or kernel mode */
        stc     ssr, r0
        rotl    r0
        rotl    r0
        bt      4f

        /* Load the kernel stack if from user mode */
        mov.l   1f, r15
4:
        clrt

        /* Set up continuation */
        mov.l   3f, r0
        lds     r0, pr

        /* Call the handler */
        /* handle(sh_context_t* context) */
        mov.l   2f, r0
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   handle_instruction_exception
3:      .long   common_return
END_LOCAL_PROC(exp_instruction_exception)


BEGIN_LOCAL_PROC(exp_address_error)
        SAVE_CONTEXT
        /* Using register bank 0 (non-privileged bank) */

        /*
         * Pass the exception code to the handler (a C function) via the
         * first argument. r0 in bank1 holds EXPEVT.
         */
        stc     r0_bank, r4

        /*
         * Pass the current SP, which points at sh_context_t, to the handler
         * via the second argument
         */
        mov     r15, r5

        /* Load the kernel stack */
        mov.l   1f, r15

        /* Set up continuation */
        mov.l   2f, r0
        lds     r0, pr

        /* Call the handler */
        /* handle(sh_context_t* context) */
        mov.l   3f, r0
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   common_return
3:      .long   handle_address_error
END_LOCAL_PROC(exp_instruction_exception)


BEGIN_LOCAL_PROC(exp_user_break)
        //TODO
        mov.l   2f, r0
        jmp     @r0
        nop

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   handle_user_break
END_LOCAL_PROC(exp_user_break)


/*
 * TRAPA Handler (Exception code: 0x160)
 * Deals with three conditions:
 * 1) System calls
 * 2) Non-L4 system calls
 * 3) Other
 */
BEGIN_LOCAL_PROC(exp_trapa_handler)
        /* Using register bank 1 (privileged bank) */

        /* See if the TRAPA code indicates a system call */
        mov.l   2f, r0
        mov.l   @r0, r0
        /* Omit 2 LSBs.  See the manual.  */
        shlr2   r0
        cmp/eq  #SYSCALL_NUM, r0
        bt      syscall_handler

        /* Not an OKL4 system call. */
        SAVE_CONTEXT
        /* Using register bank 0 */

        /* Pass the context via the first argument */
        mov     r15, r4

        /* Load the kernel stack */
        mov.l   1f, r15

        /* Set the return address */
        mov.l   4f, r0
        lds     r0, pr

        /* Invoke the handler */
        mov.l   3f, r0
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   REG_TRA
3:      .long   handle_syscall_exception
4:      .long   common_return

END_LOCAL_PROC(exp_traps_handler)


/*
 * System call handler
 */
BEGIN_LOCAL_PROC(syscall_handler)
        /* Using register bank 1 */

        /* Branch to misc L4 syscalls */
        mov.l   4f, r0
        cmp/hi  r8, r0
        bt      syscall_misc

        /* Save the control and system registers to TCB */
        mov.l   2f, r0
        add     #OFS_GLOBAL_CURRENT_TCB, r0
        mov.l   @r0, r0
        add     #OFS_TCB_ARCH_CONTEXT, r0
        mov.l   3f, r1
        add     r1, r0
        stc.l   sgr, @-r0
        stc.l   spc, @-r0
        stc.l   ssr, @-r0
        sts.l   pr, @-r0
        sts.l   macl, @-r0
        sts.l   mach, @-r0

        /* Switch to the kernel stack */
        mov.l   1f, r15

        /* Set the return address */
        mov     r8, r0
        cmp/eq  #SYSCALL_ipc, r0
        mov.l   syscall_return, r0
        bf      5f
        mov.l   ipc_syscall_return, r0
5:
        lds     r0, pr

        SWITCH_BANK_1_TO_0

        /* Using register bank 0 (user bank) */

        /* Restore the 5th-8th arguments */
        mov.l   r3, @-r15
        mov.l   r2, @-r15
        mov.l   r1, @-r15
        mov.l   r0, @-r15

        /* Call it.  r8 holds syscall number. */
        mov.l   sh_syscall_vectors, r0
        shll2   r8
        add     r8, r0
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   SH_GLOBAL_BASE
3:      .long   SIZEOF_CONTEXT
4:      .long   SYSCALL_limit

LABEL(sh_syscall_vectors)
        .long   sys_ipc
        .long   sys_thread_switch
        .long   sys_thread_control
        .long   sys_exchange_registers
        .long   sys_schedule
        .long   sys_map_control
        .long   sys_space_control
        .long   sys_cache_control
        .long   sys_ipc             /* lipc */
        .long   sys_platform_control
        .long   sys_space_switch
        .long   sys_mutex
        .long   sys_mutex_control
        .long   sys_interrupt_control
        .long   sys_cap_control
        .long   sys_memory_copy
END_LOCAL_PROC(syscall_handler)


BEGIN_PROC(ipc_syscall_return)
        mov.l   1f, r15
        add     #OFS_GLOBAL_CURRENT_TCB, r15
        mov.l   @r15, r15
        mov.l   2f, r14
        add     r14, r15
        mov.l   @r15, r0

        /* FALL THROUGH */

LABEL(syscall_return)
        /* Restore the control and system registers from TCB */
        mov.l   1f, r15
        add     #OFS_GLOBAL_CURRENT_TCB, r15
        mov.l   @r15, r15
        add     #OFS_TCB_ARCH_CONTEXT, r15
        mov.l   3f, r14
        add     r14, r15
        
        lds.l   @r15+, mach
        lds.l   @r15+, macl
        lds.l   @r15+, pr
        ldc.l   @r15+, ssr
        ldc.l   @r15+, spc
        /*ldc.l   @r15+, sgr */
        stc     sgr, r15
        rte
        nop    
        /* NOT REACHED */

        ALIGN   4
1:      .long   SH_GLOBAL_BASE
2:      .long   OFS_TCB_PARTNER
3:      .long   OFS_CONTEXT_MACH

END_PROC(syscall_return)


BEGIN_LOCAL_PROC(syscall_misc)
        SAVE_CONTEXT

        /* Pass the context via the first argument */
        mov     r15, r4

        /* Load the kernel stack */
        mov.l   1f, r15

        /* Set return address */
        mov.l   3f, r0
        lds     r0, pr

        mov.l   2f, r0
        jmp     @r0
        nop

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   sys_sh_misc
3:      .long   common_return
END_LOCAL_PROC(syscall_misc)


