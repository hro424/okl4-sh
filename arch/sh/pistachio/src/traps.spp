/* $Id$ */

/**
 * @brief   SH7780 Trap Handling
 * @file    pistachio/src/traps.spp
 * @since   December 8, 2008
 */

#include <asmsyms.h>
#include <tcb_layout.h>
#include <arch/config.h>
#include <arch/exception.h>
#include <arch/globals.h>
#include <arch/syscalls.h>
#include <arch/thread.h>
#include <kernel/arch/asm.h>
#include <kernel/arch/config.h>


#define KERNEL_STACK                __stack + STACK_TOP
#define GENERAL_EXCEPTION_HANDLER   do_general_exception
#define SYSCALL_EXCEPTION_HANDLER   do_syscall_exception
#define TLB_HANDLER                 do_tlb_exception
#define IRQ_HANDLER                 soc_handle_interrupt

#define SWITCH_BANK_1_TO_0              \
    stc     sr, r0;                     \
    /* Make the mask to switch the bank */  \
    mov     #0x20, r1;                  \
    shll8   r1;                         \
    shll16  r1;                         \
    not     r1, r1;                     \
    /* Switch bank 1 to bank 0 */       \
    and     r1, r0;                     \
    ldc     r0, sr

#define SAVE_CONTEXT                    \
    stc.l   sgr, @-r15;                 \
    stc.l   spc, @-r15;                 \
    stc.l   ssr, @-r15;                 \
    sts.l   pr, @-r15;                  \
    sts.l   macl, @-r15;                \
    sts.l   mach, @-r15;                \
    /* The current bank is 1.  */       \
    SWITCH_BANK_1_TO_0;                 \
    /* Push the rest of the registers on to the stack */    \
    PUSH(r14);                          \
    PUSH(r13);                          \
    PUSH(r12);                          \
    PUSH(r11);                          \
    PUSH(r10);                          \
    PUSH(r9);                           \
    PUSH(r8);                           \
    PUSH(r7);                           \
    PUSH(r6);                           \
    PUSH(r5);                           \
    PUSH(r4);                           \
    PUSH(r3);                           \
    PUSH(r2);                           \
    PUSH(r1);                           \
    PUSH(r0)


#define RESTORE_CONTEXT                 \
    POP(r0);                            \
    POP(r1);                            \
    POP(r2);                            \
    POP(r3);                            \
    POP(r4);                            \
    POP(r5);                            \
    POP(r6);                            \
    POP(r7);                            \
    POP(r8);                            \
    POP(r9);                            \
    POP(r10);                           \
    POP(r11);                           \
    POP(r12);                           \
    POP(r13);                           \
    POP(r14);                           \
    lds.l   @r15+, mach;                \
    lds.l   @r15+, macl;                \
    lds.l   @r15+, pr;                  \
    ldc.l   @r15+, ssr;                 \
    ldc.l   @r15+, spc;                 \
    /*XXX: Compile error: ldc.l   @r15+, sgr; */                \
    mov.l   @r15, r15

#define EXP_VECTOR(offset, handler)     \
    .balign offset;                     \
    mov.l   1f, r1;                     \
    jmp     @r1;                        \
    nop;                                \
    .balign 4;                          \
1:  .long   handler;




/*
 * Locate the trap vector in the P1 or P2 domain in order to avoid double
 * fault.
 *
 * P1 (0x80000000 - 0x9FFFFFFF):
 *      Cacheable but address translation via TLB is impossible.
 * P2 (0xA0000000 - 0xBFFFFFFF):
 *      Uncacheable and address translation via TLB is impossible.
 */

/*
 * Initialize the layout of the trap handler
 */
TRAPS_BEGIN_MARKER

/*
 * GENERAL EXCEPTION HANDLER (VBR, Offset:0x100)
 */
BEGIN_PROC_TRAPS(sh_exception, 0x100)

    /* Using register bank 1 (privileged bank) */

    /*
     * Store the exception event register, which includes 11-bit of
     * exception code, to r0 in bank1.
     */
    mov.l   1f, r0
    mov.l   @r0, r0

    /* Branch to a vector.  r0 holds EXPEVT */
    mov.l   2f, r1
    add     r0, r1
    jmp     @r1
    nop
    /* NOT REACHED */

    ALIGN   4
1:  .long   REG_EXPEVT
2:  .long   sh_exception

    ALIGN   0x80

    /* Vector 1: TLB Protection Violation (read) (offset: 0xA0) */
    EXP_VECTOR(0x20, exp_pf_handler)

    /* Vector 2: TLB Protection Violation (write) (offset: 0xC0) */
    EXP_VECTOR(0x20, exp_pf_handler)

    /* Vector 3: Address Error (read) (offset: 0xE0) */
    EXP_VECTOR(0x20, exp_error_handler)

    /* Vector 4: Address Error (write) (offset: 0x100) */
    EXP_VECTOR(0x20, exp_error_handler)

    /* Vector 5: FPU Exception (offset: 0x120) */
    EXP_VECTOR(0x20, exp_exception_handler)

    /* Vector 6: TRAPA (offset: 0x160) */
    EXP_VECTOR(0x40, exp_trapa_handler)

    /* Vector 7: Invalid Instruction (offset: 0x180) */
    EXP_VECTOR(0x20, exp_error_handler)

    /* Vector 8: Slot Invalid Instruction (offset: 0x1A0) */
    EXP_VECTOR(0x20, exp_error_handler)

    /* Vector 9: User Break (offset: 0x1E0) */
    EXP_VECTOR(0x40, exp_error_handler)

END_PROC_TRAPS(sh_exception)

/*
 * Aborts the process.  Enter KDB if available.
 */
BEGIN_LOCAL_PROC(exp_error_handler)
    //TODO
    rte
    nop
END_LOCAL_PROC(exp_error_handler)

/*
 * Invokes the page fault handler that sends a page fault message to user.
 */
BEGIN_LOCAL_PROC(exp_pf_handler)
    /* Load the kernel stack */
    mov.l   1f, r15
    SAVE_CONTEXT

    /* Using register bank 0 (non-privileged bank) */

    /*
     * Pass EXPEVT and the current context to the handler via the first
     * and second arguments.
     */
    /* r0 in bank1 holds EXPEVT. */
    stc     r0_bank, r4
    mov     r15, r5

    /* Set up continuation */
    mov.l   common_return, r0
    lds     r0, pr

    /*
     * Call the handler
     */
    mov.l   2f, r0
    jmp     @r0
    nop
    /* NOT REACHED */

    ALIGN 4
1:  .long   KERNEL_STACK
2:  .long   TLB_HANDLER

END_LOCAL_PROC(exp_pf_handler)


/*
 * Invokes the exception handler that sends an exception message to user.
 */
BEGIN_LOCAL_PROC(exp_exception_handler)
    /* Load the kernel stack */
    mov.l   1f, r15
    SAVE_CONTEXT

    /* Using register bank 0 (non-privileged bank) */

    /*
     * Pass the exception code to the handler (a C function) via the
     * first argument. r0 in bank1 holds EXPEVT.
     */
    stc     r0_bank, r4

    /*
     * Pass the current SP, which points at sh_context_t, to the handler
     * via the second argument
     */
    mov     r15, r5

    /* Set up continuation */
    mov.l   common_return, r0
    lds     r0, pr

    /* Call the handler */
    /* handle(uint32_t exception, sh_context_t* context) */
    mov.l   2f, r0
    jmp     @r0
    nop
    /* NOT REACHED */

    ALIGN   4
1:  .long   KERNEL_STACK
2:  .long   GENERAL_EXCEPTION_HANDLER

END_LOCAL_PROC(exp_exception_handler)


/*
 * TRAPA Handler (Exception code: 0x160)
 * Deals with syscall.
 */
BEGIN_LOCAL_PROC(exp_trapa_handler)
    /* Using register bank 1 (privileged bank) */

    /* See if the TRAPA code indicates a system call */
    mov.l   2f, r0
    mov.l   @r0, r0
    /* Omit 2 LSBs.  See the manual.  */
    shlr2   r0
    cmp/eq  #SYSCALL_NUM, r0
    bt      syscall_handler

    /* Not an OKL4 system call.  Throw a system call exception?  */
    mov.l   1f, r15
    SAVE_CONTEXT

    /*TODO: Handle non-OKL4 system calls */

    /* Using register bank 0 */

    mov     r15, r4

    /* Set the return address */
    mov.l   common_return, r0
    lds     r0, pr

    /* Invoke the handler */
    /* handle(sh_context_t* context) */
    mov.l   3f, r0
    jmp     @r0
    nop
    /* NOT REACHED */

    ALIGN   4
1:  .long   KERNEL_STACK
2:  .long   REG_TRA
3:  .long   SYSCALL_EXCEPTION_HANDLER

END_LOCAL_PROC(exp_traps_handler)


BEGIN_LOCAL_PROC(common_return)
    /* Restore context from TCB */
    mov.l   1f, r15
    add     #OFS_GLOBAL_CURRENT_TCB, r15
    mov.l   @r15, r15
    add     #OFS_TCB_ARCH_CONTEXT, r15
    RESTORE_CONTEXT
    rte
    nop
    /* NOT REACHED */
    ALIGN   4
1:  .long   SH_GLOBAL_BASE
END_LOCAL_PROC(common_return)


/*
 * System call handler
 */
BEGIN_LOCAL_PROC(syscall_handler)
    /* Using register bank 1 */

    /* Save the control and system registers to TCB */
    mov.l   3f, r0
    add     #OFS_GLOBAL_CURRENT_TCB, r0
    mov.l   @r0, r0
    add     #OFS_TCB_ARCH_CONTEXT, r0
    mov.l   4f, r1
    add     r1, r0
    stc.l   sgr, @-r0
    stc.l   spc, @-r0
    stc.l   ssr, @-r0
    sts.l   pr, @-r0
    sts.l   macl, @-r0
    sts.l   mach, @-r0

    /* Switch to the kernel stack */
    mov.l   2f, r15

    /* Set the return address */
    mov     r8, r0
    cmp/eq  #SYSCALL_ipc, r0
    mov.l   syscall_return, r0
    bf      1f
    mov.l   ipc_syscall_return, r0
1:
    lds     r0, pr

    SWITCH_BANK_1_TO_0

    /* Using register bank 0 */

    /* Restore the 5th-8th arguments */
    mov.l   r3, @-r15
    mov.l   r2, @-r15
    mov.l   r1, @-r15
    mov.l   r0, @-r15

    /* Call it.  r8 holds syscall number. */
    mov.l   sh_syscall_vectors, r0
    shll2   r8
    add     r8, r0
    jmp     @r0
    nop
    /* NOT REACHED */

    /* Constant values and function pointers */
    ALIGN   4
2:  .long   KERNEL_STACK
3:  .long   SH_GLOBAL_BASE
4:  .long   SIZEOF_CONTEXT

LABEL(sh_syscall_vectors)
    .long   sys_ipc
    .long   sys_thread_switch
    .long   sys_thread_control
    .long   sys_exchange_registers
    .long   sys_schedule
    .long   sys_map_control
    .long   sys_space_control
    .long   sys_cache_control
    .long   sys_ipc             /* lipc */
    .long   sys_platform_control
    .long   sys_space_switch
    .long   sys_mutex
    .long   sys_mutex_control
    .long   sys_interrupt_control
    .long   sys_cap_control
    .long   sys_memory_copy
END_LOCAL_PROC(syscall_handler)


BEGIN_PROC(ipc_syscall_return)
    mov.l   1f, r15
    add     #OFS_GLOBAL_CURRENT_TCB, r15
    mov.l   @r15, r15
    mov.l   2f, r14
    add     r14, r15
    mov.l   @r15, r0

    /* FALL THROUGH */

BEGIN_PROC(syscall_return)
    /* Restore the control and system registers from TCB */
    mov.l   1f, r15
    add     #OFS_GLOBAL_CURRENT_TCB, r15
    mov.l   @r15, r15
    add     #OFS_TCB_ARCH_CONTEXT, r15
    mov.l   3f, r14
    add     r14, r15
    
    lds.l   @r15+, mach
    lds.l   @r15+, macl
    lds.l   @r15+, pr
    ldc.l   @r15+, ssr
    ldc.l   @r15+, spc
    /*ldc.l   @r15+, sgr */
    stc     sgr, r15
    rte
    nop    
    /* NOT REACHED */

    ALIGN   4
1:  .long   SH_GLOBAL_BASE
2:  .long   OFS_TCB_PARTNER
3:  .long   OFS_CONTEXT_MACH

END_PROC(syscall_return)

BEGIN_PROC(abort_return)
    //TODO
    rte
    nop
END_PROC(abort_return)

/*
 * TLB miss handler vector
 */
BEGIN_PROC_TRAPS(sh_tlb_miss, 0x400)
    mov.l   1f, r15
    SAVE_CONTEXT

    /* Using register bank 0 */

    /*
     * The exception event register contains the access mode, such as
     * read (0x40) or write (0x60).  Pass it via the first argument.
     */
    mov.l   2f, r4
    mov.l   @r4, r4

    /* Pass SP via the second argument */
    mov     r15, r5

    /* Set up continuation */
    mov.l   4f, r0
    lds     r0, pr

    /* Call the handler */
    mov.l   3f, r0
    jsr     @r0
    nop
    /* NOT REACHED */

    /* Constant values and function pointers */
    ALIGN   4
1:  .long   KERNEL_STACK
2:  .long   REG_EXPEVT
3:  .long   TLB_HANDLER
4:  .long   common_return

END_PROC_TRAPS(sh_tlb_miss)

/*
 * IRQ handler vector
 * NOTE: Must be placed at 0x600 (= 0x400 + 0x200)
 * TODO: Handling multiple interrupts
 */
BEGIN_PROC_TRAPS(sh_interrupt, 0x200)

    /* Use the kernel stack */
    mov.l   1f, r15

    SAVE_CONTEXT

    /* Using register bank 0 */

    /*
     * Read the interrupt event register.  Pass it via the first argument.
     */
    mov.l   2f, r4
    mov.l   @r4, r4

    /* Pass the saved context via the second argument */
    mov     r15, r5

    /* Set up continuation */
    mov.l   3f, r0
    lds     r0, pr

    /* Check whether it is raised in user or kernel mode */
    stc     ssr, r0
    rotl    r0
    rotl    r0
    mov.l   4f, r0
    bt      kernel_interrupt
    jmp     @r0
    nop
    /* NOT REACHED */

LABEL(kernel_interrupt)
    /* Handle an interrupt raised in kernel mode */
    clrt
    jsr     @r0
    nop

    /* Get current TCB to get continuation */
    mov.l   5f, r15
    add     #OFS_GLOBAL_CURRENT_TCB, r15
    mov.l   @r15, r15
    add     #OFS_TCB_PREEMPTION_CONTINUATION, r15
    mov     r15, r0

    /* Reset the kernel stack */
    mov.l   1f, r15

    /* Return to continuation */
    jmp     @r0
    nop
    /* NOT REACHED */

    ALIGN   4
1:  .long   KERNEL_STACK
2:  .long   REG_INTEVT
3:  .long   common_return
4:  .long   IRQ_HANDLER
5:  .long   SH_GLOBAL_BASE

END_PROC_TRAPS(sh_interrupt)

    /*
     * The rest of general exception vectors
     * NOTE: Must be placed at VBR + 0x800
     */

    /* Vector 10: Invalid FPU Instruction (offset: 0x800) */
    EXP_VECTOR(0x200, exp_error_handler)

    /* Vector 11: Slot Invalid FPU Instruction (offset: 0x820) */
    EXP_VECTOR(0x20, exp_error_handler)


