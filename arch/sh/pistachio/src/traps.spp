/* $Id$ */

/**
 * @brief   SH7780 Trap Handling
 * @file    pistachio/src/traps.spp
 * @since   December 8, 2008
 */

#include <asmsyms.h>
#include <tcb_layout.h>
#include <arch/asm.h>
#include <arch/config.h>
#include <arch/exception.h>
#include <arch/globals.h>
#include <arch/syscalls.h>
#include <arch/thread.h>
#include <kernel/arch/asm.h> //TODO: Integrate this with asm.h
#include <kernel/arch/config.h>


#define KERNEL_STACK                __stack + STACK_TOP
#define GENERAL_EXCEPTION_HANDLER   handle_general_exception
#define SYSCALL_EXCEPTION_HANDLER   handle_syscall_exception
#define TLB_HANDLER                 handle_tlb_exception
#define IRQ_HANDLER                 soc_handle_interrupt


/*
 * Locate the trap vector in the P1 or P2 domain in order to avoid double
 * fault.
 *
 * P1 (0x80000000 - 0x9FFFFFFF):
 *      Cacheable but address translation via TLB is impossible.
 * P2 (0xA0000000 - 0xBFFFFFFF):
 *      Uncacheable and address translation via TLB is impossible.
 */

/*
 * Initialize the layout of the trap handler
 */
TRAPS_BEGIN_MARKER

/*
 * GENERAL EXCEPTION HANDLER (VBR, Offset:0x100)
 */
BEGIN_PROC_TRAPS(sh_general_exception, 0x100)
        /* Using register bank 1 (privileged bank) */

        /*
         * Store the exception event register, which includes 11-bit of
         * exception code, to r0 in bank1.
         */
        mov.l   1f, r0
        mov.l   @r0, r0

        /* Branch to a vector.  r0 holds EXPEVT */
        mov.l   2f, r1
        add     r0, r1
        jmp     @r1
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   REG_EXPEVT
2:      .long   sh_general_exception

        ALIGN   0x80
        .skip   0x20

        /*
         * General Exception Vector
         */
        /* Vector 1: TLB Protection Violation (read) (offset: 0xA0) */
        EXP_VECTOR(0x20, exp_memory_exception)

        /* Vector 2: TLB Protection Violation (write) (offset: 0xC0) */
        EXP_VECTOR(0x20, exp_memory_exception)

        /* Vector 3: Address Error (read) (offset: 0xE0) */
        EXP_VECTOR(0x20, exp_memory_exception)

        /* Vector 4: Address Error (write) (offset: 0x100) */
        EXP_VECTOR(0x20, exp_memory_exception)

        /* Vector 5: FPU Exception (offset: 0x120) */
        EXP_VECTOR(0x20, exp_exception_handler)

        /* Vector 6: TRAPA (offset: 0x160) */
        EXP_VECTOR(0x40, exp_trapa_handler)

        /* Vector 7: Invalid Instruction (offset: 0x180) */
        EXP_VECTOR(0x20, exp_error_handler)

        /* Vector 8: Slot Invalid Instruction (offset: 0x1A0) */
        EXP_VECTOR(0x20, exp_error_handler)

        /* Vector 9: User Break (offset: 0x1E0) */
        EXP_VECTOR(0x40, exp_error_handler)

END_PROC_TRAPS(sh_general_exception)


BEGIN_PROC(abort_return)
BEGIN_LOCAL_PROC(common_return)
        /* Restore the context from TCB */
        mov.l   1f, r15
        add     #OFS_GLOBAL_CURRENT_TCB, r15
        mov.l   @r15, r15
        add     #OFS_TCB_ARCH_CONTEXT, r15
        RESTORE_CONTEXT
        rte
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   SH_GLOBAL_BASE
END_LOCAL_PROC(common_return)
END_PROC(abort_return)


BEGIN_LOCAL_PROC(exp_error_handler)
        //TODO
        rte
        nop
END_LOCAL_PROC(exp_error_handler)

/*
 * Invokes the page fault handler that sends a page fault message to user.
 */
BEGIN_LOCAL_PROC(exp_memory_exception)
        /* Using register bank 1 */
        SAVE_CONTEXT
        /* Using register bank 0 (non-privileged bank) */

        /* Pass EXPEVT to the handler via the first argument.  */
        /* r0 in bank1 holds EXPEVT. */
        stc     r0_bank, r4

        /*
         * Pass the current context to the handler via the second argument.
         * The context is supposed to be saved to a TCB in the handler so that
         * the kernel return routine restores the context.
         */
        mov     r15, r5

        /* Check whether it was raised in user or kernel mode */
        stc     ssr, r0
        rotl    r0
        rotl    r0
        bt      4f

        /* Load the kernel stack if from user mode*/
        mov.l   1f, r15
4:
        clrt

        /* Set up continuation */
        mov.l   3f, r0
        lds     r0, pr

        /*
         * Call the handler
         */
        mov.l   2f, r0
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   TLB_HANDLER
3:      .long   common_return

END_LOCAL_PROC(exp_memory_exception)


/*
 * Invokes the exception handler that sends an exception message to user.
 */
BEGIN_LOCAL_PROC(exp_exception_handler)
        SAVE_CONTEXT
        /* Using register bank 0 (non-privileged bank) */

        /*
         * Pass the exception code to the handler (a C function) via the
         * first argument. r0 in bank1 holds EXPEVT.
         */
        stc     r0_bank, r4

        /*
         * Pass the current SP, which points at sh_context_t, to the handler
         * via the second argument
         */
        mov     r15, r5

        /* Check whether it was raised in user or kernel mode */
        stc     ssr, r0
        rotl    r0
        rotl    r0
        bt      4f

        /* Load the kernel stack if from user mode*/
        mov.l   1f, r15
4:
        clrt

        /* Set up continuation */
        mov.l   3f, r0
        lds     r0, pr

        /* Call the handler */
        /* handle(uint32_t exception, sh_context_t* context) */
        mov.l   2f, r0
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   GENERAL_EXCEPTION_HANDLER
3:      .long   common_return

END_LOCAL_PROC(exp_exception_handler)


/*
 * TRAPA Handler (Exception code: 0x160)
 * Deals with syscall.
 */
BEGIN_LOCAL_PROC(exp_trapa_handler)
        /* Using register bank 1 (privileged bank) */

        /* See if the TRAPA code indicates a system call */
        mov.l   2f, r0
        mov.l   @r0, r0
        /* Omit 2 LSBs.  See the manual.  */
        shlr2   r0
        cmp/eq  #SYSCALL_NUM, r0
        bt      syscall_handler

        /* Not an OKL4 system call.  Throw a system call exception?  */
        mov.l   1f, r15
        SAVE_CONTEXT

        /*TODO: Handle non-OKL4 system calls */

        /* Using register bank 0 */

        mov     r15, r4

        /* Set the return address */
        mov.l   4f, r0
        lds     r0, pr

        /* Invoke the handler */
        /* handle(sh_context_t* context) */
        mov.l   3f, r0
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   REG_TRA
3:      .long   SYSCALL_EXCEPTION_HANDLER
4:      .long   common_return

END_LOCAL_PROC(exp_traps_handler)


/*
 * System call handler
 */
BEGIN_LOCAL_PROC(syscall_handler)
    /* Using register bank 1 */

    /* Save the control and system registers to TCB */
    mov.l   3f, r0
    add     #OFS_GLOBAL_CURRENT_TCB, r0
    mov.l   @r0, r0
    add     #OFS_TCB_ARCH_CONTEXT, r0
    mov.l   4f, r1
    add     r1, r0
    stc.l   sgr, @-r0
    stc.l   spc, @-r0
    stc.l   ssr, @-r0
    sts.l   pr, @-r0
    sts.l   macl, @-r0
    sts.l   mach, @-r0

    /* Switch to the kernel stack */
    mov.l   2f, r15

    /* Set the return address */
    mov     r8, r0
    cmp/eq  #SYSCALL_ipc, r0
    mov.l   syscall_return, r0
    bf      1f
    mov.l   ipc_syscall_return, r0
1:
    lds     r0, pr

    SWITCH_BANK_1_TO_0

    /* Using register bank 0 */

    /* Restore the 5th-8th arguments */
    mov.l   r3, @-r15
    mov.l   r2, @-r15
    mov.l   r1, @-r15
    mov.l   r0, @-r15

    /* Call it.  r8 holds syscall number. */
    mov.l   sh_syscall_vectors, r0
    shll2   r8
    add     r8, r0
    jmp     @r0
    nop
    /* NOT REACHED */

    /* Constant values and function pointers */
    ALIGN   4
2:  .long   KERNEL_STACK
3:  .long   SH_GLOBAL_BASE
4:  .long   SIZEOF_CONTEXT

LABEL(sh_syscall_vectors)
    .long   sys_ipc
    .long   sys_thread_switch
    .long   sys_thread_control
    .long   sys_exchange_registers
    .long   sys_schedule
    .long   sys_map_control
    .long   sys_space_control
    .long   sys_cache_control
    .long   sys_ipc             /* lipc */
    .long   sys_platform_control
    .long   sys_space_switch
    .long   sys_mutex
    .long   sys_mutex_control
    .long   sys_interrupt_control
    .long   sys_cap_control
    .long   sys_memory_copy
END_LOCAL_PROC(syscall_handler)


BEGIN_PROC(ipc_syscall_return)
    mov.l   1f, r15
    add     #OFS_GLOBAL_CURRENT_TCB, r15
    mov.l   @r15, r15
    mov.l   2f, r14
    add     r14, r15
    mov.l   @r15, r0

    /* FALL THROUGH */

BEGIN_PROC(syscall_return)
    /* Restore the control and system registers from TCB */
    mov.l   1f, r15
    add     #OFS_GLOBAL_CURRENT_TCB, r15
    mov.l   @r15, r15
    add     #OFS_TCB_ARCH_CONTEXT, r15
    mov.l   3f, r14
    add     r14, r15
    
    lds.l   @r15+, mach
    lds.l   @r15+, macl
    lds.l   @r15+, pr
    ldc.l   @r15+, ssr
    ldc.l   @r15+, spc
    /*ldc.l   @r15+, sgr */
    stc     sgr, r15
    rte
    nop    
    /* NOT REACHED */

    ALIGN   4
1:  .long   SH_GLOBAL_BASE
2:  .long   OFS_TCB_PARTNER
3:  .long   OFS_CONTEXT_MACH

END_PROC(syscall_return)


/*
 * TLB miss handler vector
 * NOTE: Must be placed at VBR + 0x400
 */
BEGIN_PROC_TRAPS(sh_tlb_miss, 0x400)
        /* Using register bank 1 */
        SAVE_CONTEXT
        /* Using register bank 0 */

        /*
         * The exception event register contains the access mode, such as
         * read (0x40) or write (0x60).  Pass it via the first argument.
         */
        mov.l   2f, r4
        mov.l   @r4, r4

        /* Pass the context via the second argument */
        mov     r15, r5

        /* Check whether it is raised in user or kernel mode */
        stc     ssr, r0
        rotl    r0
        rotl    r0
        bt      5f

        /* Load the kernel stack if from user mode*/
        mov.l   1f, r15
5:
        clrt

        /* Set up continuation */
        mov.l   4f, r0
        lds     r0, pr

        /* Call the handler */
        mov.l   3f, r0
        jsr     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   REG_EXPEVT
3:      .long   TLB_HANDLER
4:      .long   common_return

END_PROC_TRAPS(sh_tlb_miss)


/*
 * IRQ handler vector
 * NOTE: Must be placed at 0x600 (= 0x400 + 0x200)
 * TODO: Handling multiple interrupts
 */
BEGIN_PROC_TRAPS(sh_interrupt, 0x200)
        SAVE_CONTEXT
        /* Using register bank 0 */

        /*
         * Read the interrupt event register.
         * Pass it via the first argument.
         */
        mov.l   2f, r4
        mov.l   @r4, r4

        /* Pass the saved context via the second argument */
        mov     r15, r5

        /* Set up continuation */
        mov.l   3f, r0
        lds     r0, pr

        /* Check whether it is raised in user or kernel mode */
        stc     ssr, r0
        rotl    r0
        rotl    r0
        bt      kernel_interrupt

        /* Load the kernel stack */
        mov.l   1f, r15

        mov.l   4f, r0
        jmp     @r0
        nop
        /* NOT REACHED */

LABEL(kernel_interrupt)
        /* Handle an interrupt raised in kernel mode */
        clrt
        mov.l   4f, r0
        jsr     @r0
        nop

        /* Get current TCB to get continuation */
        mov.l   5f, r15
        add     #OFS_GLOBAL_CURRENT_TCB, r15
        mov.l   @r15, r15
        add     #OFS_TCB_PREEMPTION_CONTINUATION, r15
        mov     r15, r0

        /* Reset the kernel stack */
        mov.l   1f, r15

        /* Return to continuation */
        jmp     @r0
        nop
        /* NOT REACHED */

        ALIGN   4
1:      .long   KERNEL_STACK
2:      .long   REG_INTEVT
3:      .long   common_return
4:      .long   IRQ_HANDLER
5:      .long   SH_GLOBAL_BASE

END_PROC_TRAPS(sh_interrupt)

/*
 * The rest of general exception vectors
 * NOTE: Must be placed at VBR + 0x800
 */
        /* Vector 10: Invalid FPU Instruction (offset: 0x800) */
        EXP_VECTOR(0x200, exp_error_handler)

        /* Vector 11: Slot Invalid FPU Instruction (offset: 0x820) */
        EXP_VECTOR(0x20, exp_error_handler)

