/*****************************************************************
 * DO NOT EDIT - MACHINE-GENERATED FILE!
 * 
 * Source file : ../input/kernelmsg.idl
 * Platform    : V4 Generic
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.0.2 (roadrunner) on 16/06/2006 17:37
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#if !defined(__kernelmsg_server_h__)
#define __kernelmsg_server_h__

#define IDL4_OMIT_FRAME_POINTER 0
#define IDL4_USE_FASTCALL 0
#define IDL4_NEED_MALLOC 1
#define IDL4_API v4
#define IDL4_ARCH generic

#include "idl4/idl4.h"

#if IDL4_HEADER_REVISION < 20030403
#error You are using outdated versions of the IDL4 header files
#endif /* IDL4_HEADER_REVISION < 20030403 */

/* Interface with_kernelmsg */

void with_kernelmsg_server(void);
void with_kernelmsg_discard(void);

#define WITH_KERNELMSG_DEFAULT_VTABLE { with_kernelmsg_discard, service_with_kernelmsg_fake_pagefault }
#define WITH_KERNELMSG_DEFAULT_VTABLE_SIZE 2
#define WITH_KERNELMSG_MAX_FID 1
#define WITH_KERNELMSG_DEFAULT_KTABLE { with_kernelmsg_discard, with_kernelmsg_discard, service_with_kernelmsg_pagefault, with_kernelmsg_discard }
#define WITH_KERNELMSG_DEFAULT_KTABLE_SIZE 4
#define WITH_KERNELMSG_MSGBUF_SIZE 0
#define WITH_KERNELMSG_STRBUF_SIZE 0
#define WITH_KERNELMSG_FID_MASK 1
#define WITH_KERNELMSG_KID_MASK 0x3

typedef union {
  struct {
    long _msgtag;
    CORBA_long addr;
    CORBA_long ip;
  } _in;
  struct {
    long _spacer[64];
    long _msgtag;
    idl4_mapitem fp;
  } _out;
  struct {
    long _spacer[128];
    idl4_inverse_stringitem _str[16];
    long _acceptor;
  } _buf;
} _param_with_kernelmsg_pagefault;

long service_with_kernelmsg_pagefault(L4_ThreadId_t _caller, _param_with_kernelmsg_pagefault *_par);

inline void with_kernelmsg_pagefault_implementation(CORBA_Object _caller, const CORBA_long addr, const CORBA_long ip, const CORBA_long priv, idl4_fpage_t *fp, idl4_server_environment *_env);

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: long _msgtag                 6    0    4    4 -p---  -1
//   R4: CORBA_long addr              2    4    4    4 x----  -1
//   R8: CORBA_long ip                3    8    4    4 x----  -1
//   X-: CORBA_long priv              4   -1    4    4 x-1--  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: long _msgtag                 7   -1    4    4 -p---  -1
//   F0: idl4_fpage_t fp              5    0    1    1 x----  -1

#define IDL4_PUBLISH_WITH_KERNELMSG_PAGEFAULT(_func) long service_with_kernelmsg_pagefault(L4_ThreadId_t _caller, _param_with_kernelmsg_pagefault *_par)\
\
{ \
  idl4_server_environment _env; \
\
  _env._action = 0;\
\
  /* invoke service */ \
   \
  _func(_caller, _par->_in.addr, _par->_in.ip, (_par->_in._msgtag >> 16) & 7, &_par->_out.fp, &_env);\
\
  if (IDL4_EXPECT_TRUE(_env._action == 0)) \
    { \
      /* marshal */ \
       \
      _par->_out.fp = _par->_out.fp;\
\
      /* jump back */ \
       \
      _par->_out._msgtag = (2 << 6)+0;\
      return 2; \
    } \
\
  return -1; \
} \

#define IDL4_PUBLISH_with_kernelmsg_pagefault IDL4_PUBLISH_WITH_KERNELMSG_PAGEFAULT

static inline void with_kernelmsg_pagefault_reply(CORBA_Object _client, idl4_fpage_t *fp)

{
  struct _reply_buffer {
    struct {
      long _msgtag;
      idl4_mapitem fp;
    } _out;
  } _buf;
  struct _reply_buffer *_par = &_buf;

  /* marshal reply */
  
  _par->_out.fp = *fp;

  /* send message */
  
  _buf._out._msgtag = 0+(2 << 6);
  L4_MsgLoad((L4_Msg_t *)((void*)_par));
  L4_Send_Timeout(_client, L4_ZeroTime);
}

typedef union {
  struct {
    long _msgtag;
    CORBA_long addr;
    CORBA_long ip;
    CORBA_long priv;
  } _in;
  struct {
    long _spacer[64];
    long _msgtag;
    idl4_mapitem fp;
  } _out;
  struct {
    long _spacer[128];
    idl4_inverse_stringitem _str[16];
    long _acceptor;
  } _buf;
} _param_with_kernelmsg_fake_pagefault;

long service_with_kernelmsg_fake_pagefault(L4_ThreadId_t _caller, _param_with_kernelmsg_fake_pagefault *_par);

inline void with_kernelmsg_fake_pagefault_implementation(CORBA_Object _caller, const CORBA_long addr, const CORBA_long ip, const CORBA_long priv, idl4_fpage_t *fp, idl4_server_environment *_env);

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: long _msgtag                 6    0    4    4 -p---  -1
//   R4: CORBA_long addr              2    4    4    4 x----  -1
//   R8: CORBA_long ip                3    8    4    4 x----  -1
//   R12: CORBA_long priv             4   12    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: long _msgtag                 7   -1    4    4 -p---  -1
//   F0: idl4_fpage_t fp              5    0    1    1 x----  -1

#define IDL4_PUBLISH_WITH_KERNELMSG_FAKE_PAGEFAULT(_func) long service_with_kernelmsg_fake_pagefault(L4_ThreadId_t _caller, _param_with_kernelmsg_fake_pagefault *_par)\
\
{ \
  idl4_server_environment _env; \
\
  _env._action = 0;\
\
  /* invoke service */ \
   \
  _func(_caller, _par->_in.addr, _par->_in.ip, _par->_in.priv, &_par->_out.fp, &_env);\
\
  if (IDL4_EXPECT_TRUE(_env._action == 0)) \
    { \
      /* marshal */ \
       \
      _par->_out.fp = _par->_out.fp;\
\
      /* jump back */ \
       \
      _par->_out._msgtag = (2 << 6)+0;\
      return 2; \
    } \
\
  return -1; \
} \

#define IDL4_PUBLISH_with_kernelmsg_fake_pagefault IDL4_PUBLISH_WITH_KERNELMSG_FAKE_PAGEFAULT

static inline void with_kernelmsg_fake_pagefault_reply(CORBA_Object _client, idl4_fpage_t *fp)

{
  struct _reply_buffer {
    struct {
      long _msgtag;
      idl4_mapitem fp;
    } _out;
  } _buf;
  struct _reply_buffer *_par = &_buf;

  /* marshal reply */
  
  _par->_out.fp = *fp;

  /* send message */
  
  _buf._out._msgtag = 0+(2 << 6);
  L4_MsgLoad((L4_Msg_t *)((void*)_par));
  L4_Send_Timeout(_client, L4_ZeroTime);
}

#endif /* !defined(__kernelmsg_server_h__) */
