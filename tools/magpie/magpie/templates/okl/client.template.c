!!explicit_linebreaks
/* \n
 * This is an automatically-generated file.\n
 * Source file  : {*-?generator.get_idl_filename()-*}\n
 * Output file  : {*-?generator.get_output_filename()-*}\n
 * Platform     : OKL4 (Generic)\n
 * Mapping      : {*-?templates.MAPPING-*}\n
 *\n
 * Generated by {*-?file.version_string-*}\n
*/\n
\n
#if !defined(/*-?generator.get_ifdefable_filename()-*/)\n
#define /*-?generator.get_ifdefable_filename()-*/\n
/* IDL4 compatibility */\n
#define IDL4_OMIT_FRAME_POINTER 0 /* Unimplemented */\n
#define IDL4_USE_FASTCALL 0 /* Unimplemented */\n
#define IDL4_NEED_MALLOC 0 /* Unimplemented */\n
#define IDL4_API v4\n
#define IDL4_ARCH generic_biguuid\n
\n
#define MAGPIE_BYTES_PER_WORD (sizeof(L4_Word_t))\n
\n
/* Include IDL4-compat and magpie files */\n
#ifdef __cplusplus\n
extern "C" {\n
#endif\n
#include "idl4biguuid/idl4.h"\n
#include "idl4biguuid/magpie.h"\n
#include "l4/message.h"\n
#ifdef __cplusplus\n
}\n
#endif\n
\n
/* Include IDL-specific imports */\n
/*LOOP importname = generator.get_imports()*/
#include "/*-?importname-*/"\n
/*ENDLOOP*/
\n
/*\n
 # Define all integer constants as C preprocessor #defines.  \n
 # This can be used to get around the fact that you can't switch on const\n
 # ints in C, but only on int literals.\n
-*/\n
/*LOOP type_ast = generator.search( ['type_instance', {'meta_type': 'const'}] )*/
/*-basic_type = type_ast.the('target').the('type')-*/
/*-if basic_type.leaf in ('int', 'unsigned int', 'long', 'unsigned long', 'signed int', 'signed long')*/
#define _C_/*-?type_ast.leaf.upper()-*/ /*-?flatten(type_ast.the('declarator').the('expression'))-*/\n
#define /*-?type_ast.leaf.upper()-*/ /*-?flatten(type_ast.the('declarator').the('expression'))-*/\n
/*fi-*/
/*ENDLOOP*/
\n
/*LOOP interface = generator.get_interfaces()*/
/* Interface {*-?interface.get_name()-*} */
#if !defined(/*-?interface.get_ifdef_name()-*/)\n
#define /*-?interface.get_ifdef_name()-*/\n
typedef CORBA_Object /*-?interface.get_name()-*/;\n
#endif // !defined(/*-?interface.get_ifdef_name()-*/)\n
/*LOOP function = interface.get_functions()*/
/*-
function.rename_args({'fpage': 'idl4_fpage_t'})
# The C interface dictates we start with a service pointer and end with environment.
call_param_list = ['%s _service' % (interface.get_name())]
for param in function.get_call_params():
	call_param_list.append('%s %s' % (param.c_typename, param['name']))
call_param_list.append('CORBA_Environment *_env')
-*/
#if !defined(/*-?function.get_ifdef_name()-*/)\n
#define /*-?function.get_ifdef_name()-*/\n
/* Biguuid generic code: {*-?function.get_defable_name()-*}_CALL_ID is simply the function number.\n
 * The interface ID is encoded as a separate input parameter. \n
*/\n
#define /*-?function.get_defable_name()-*/_CALL_ID (/*-?function.get_number()-*/u)\n
static inline /*-?function.get_return_type('client')-*/ /*-?function.get_name()-*/ (/*-?', '.join (call_param_list)-*/)\n
{\n
/*-if function.get_is_pagefault()*/
	/* Page-fault handler */\n
	long _exception;\n
	L4_MsgTag_t _result;\n
	L4_Word_t _asynch_mask;\n
\n
	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */\n
	volatile union _buf {\n
		struct {\n
			long _msgtag;\n
			signed int addr;\n
			signed int ip;\n
		} _in;\n
		struct {\n
			long _msgtag;\n
			idl4_mapitem fp;\n
		} _out;\n
	} _pack;\n
	/* marshal */\n
	L4_Accept(_env->_rcv_window);\n
	_pack._in.addr = (int)addr;\n
	_pack._in.ip = (int)ip;\n
\n
	/* invoke IPC: NB we subtract the size of _msgtag. */\n
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((/*-?function.get_defable_name()-*/_CALL_ID+(priv & 7)) << 16);\n
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));\n
	L4_Accept(_env->_rcv_window);\n
	_asynch_mask = L4_Get_NotifyMask();\n
	L4_Set_NotifyMask(0);\n
\n
	_result = L4_Call(_service);\n
	L4_Set_NotifyMask(_asynch_mask);\n
\n
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));\n
	L4_Accept(L4_UntypedWordsAcceptor);\n
\n
	_exception = L4_Label(_result);\n
\n
	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {\n
		*fp = _pack._out.fp;\n
	}\n
\n
	if (_env != 0) {\n
		if (!L4_IpcSucceeded(_result)) {\n
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);\n
		} else {\n
			*(L4_Word_t *)_env = _exception;\n
		}\n
	}\n
/*fi-*/
/*-if not function.get_is_pagefault()*/
	/*- # Function parameters -*/\n
	long _exception;\n
	L4_MsgTag_t __result; /* Result of L4_Call */ \n
	byte *mr = (void *)L4_MRStart(); /* Beginning of message registers */ \n
/*-if function.is_nonvoid()*/
	/*-?function.get_return_type()-*/ __return;\n
/*fi-*/
/*-if function.has_varlength_params_in()*/
	byte *mr_varptr = mr; /* Variable-length param buffer pointer */\n
/*fi-*/
	/* pre_ipc_defs */\n
	L4_Word_t _asynch_mask;\n
	\n


	/* Set the interface ID  - second word*/\n
	*((L4_Word_t *)(void *)(&mr[MAGPIE_BYTES_PER_WORD])) = /*-?interface.get_uuid()-*/;\n
	\n


	/* Marshal */\n
/*LOOP cmd, args = function.marshal('in', startword = 2)*/
	/*-run(templates.get(cmd), args = args)-*/
/*ENDLOOP*/

	/* Set the message tag = function number, number of message registers used.*/\n
/*-if function.has_varlength_params_in()*/
	/* Number of registers used depends on length of variable-length portion */\n
	*((L4_Word_t *)(void *)(&mr[0])) = ((L4_Word_t)(mr_varptr - mr) / sizeof(L4_Word_t)) + ((/*-?function.get_defable_name()-*/_CALL_ID) << 16);\n
/*fi-*/
/*-if not function.has_varlength_params_in()*/
	*((L4_Word_t *)(void *)(&mr[0])) = 2 + /*-? function.marshal_size_inwords_in()-*/ + ((/*-?function.get_defable_name()-*/_CALL_ID) << 16);\n
/*fi-*/



	/* Do the IPC */\n
	/* pre_ipc */\n
	_asynch_mask = L4_Get_NotifyMask();
	L4_Set_NotifyMask(0);
	__result = L4_Call(_service);\n
	/* post_ipc */\n
	L4_Set_NotifyMask(_asynch_mask);\n
	\n

	_exception = L4_Label(__result);\n
	\n


	/* Unmarshal */\n
/*LOOP cmd, args = function.unmarshal('out', startword = 1)*/
	/*-run(templates.get(cmd), args = args)-*/
/*ENDLOOP*/
	\n



/*- # Generic clag for exception handling -*/
	if (_env != 0) {\n
		if (!L4_IpcSucceeded(__result)) {\n
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);\n
		} else {\n
			*(L4_Word_t *)_env = _exception;\n
		}\n
	}\n
	\n



	/*-if function.get_return_type() != 'void'*//* Return normally. */\n
	return __return;\n
	/*fi-*/
/*fi-*/
}\n
#endif // !defined(/*-?function.get_ifdef_name()-*/)\n
/* End of function */\n
/*ENDLOOP*/
\n
/* End of interface */\n
/*ENDLOOP*/

#endif //{*-?generator.get_ifdefable_filename()-*}\n

